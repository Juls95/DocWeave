"""Component: Generate documentation from analysis results."""

from pathlib import Path
from typing import Optional

from docweave.types.models import CodeAnalysis, CommitInfo, DocumentationResult


async def generate_documentation(
    commits: list[CommitInfo],
    analyses: list[CodeAnalysis],
    repo_name: str,
) -> DocumentationResult:
    """
    Generate markdown documentation and Mermaid diagrams from commits and analyses.

    Args:
        commits: List of commit information
        analyses: List of code analyses from Copilot
        repo_name: Name of the repository

    Returns:
        DocumentationResult with generated content
    """
    # Generate markdown content
    markdown = _generate_markdown(commits, analyses, repo_name)

    # Generate Mermaid diagrams
    mermaid_diagrams = _generate_mermaid_diagrams(commits, analyses)

    # Generate narrative
    narrative = _generate_narrative(commits, analyses)

    # Extract next steps
    next_steps = []
    for analysis in analyses:
        next_steps.extend(analysis.next_steps)
    next_steps = list(dict.fromkeys(next_steps))[:5]  # Remove duplicates, limit to 5

    return DocumentationResult(
        markdown_content=markdown,
        mermaid_diagrams=mermaid_diagrams,
        narrative=narrative,
        next_steps=next_steps,
    )


def _generate_markdown(
    commits: list[CommitInfo], analyses: list[CodeAnalysis], repo_name: str
) -> str:
    """Generate markdown documentation."""
    md = f"# {repo_name} - Recent Changes Documentation\n\n"
    md += f"*Generated by DocWeave - Documentation companion powered by GitHub Copilot CLI*\n\n"
    md += "---\n\n"

    for i, (commit, analysis) in enumerate(zip(commits, analyses), 1):
        md += f"## Commit {i}: {commit.message.split(chr(10))[0]}\n\n"
        md += f"**SHA:** `{commit.sha}`  \n"
        md += f"**Author:** {commit.author}  \n"
        md += f"**Date:** {commit.date.strftime('%Y-%m-%d %H:%M:%S')}  \n"
        md += f"**Changes:** +{commit.additions} / -{commit.deletions} lines  \n\n"

        md += f"### Summary\n\n{analysis.summary}\n\n"

        md += f"### Why This Change?\n\n{analysis.why}\n\n"

        md += f"### Importance: {analysis.importance.upper()}\n\n"

        if commit.files_changed:
            md += f"### Files Changed\n\n"
            for file in commit.files_changed[:10]:  # Limit to 10 files
                md += f"- `{file}`\n"
            if len(commit.files_changed) > 10:
                md += f"- *... and {len(commit.files_changed) - 10} more files*\n"
            md += "\n"

        if analysis.next_steps:
            md += f"### Suggested Next Steps\n\n"
            for step in analysis.next_steps:
                md += f"- {step}\n"
            md += "\n"

        md += "---\n\n"

    return md


def _generate_mermaid_diagrams(
    commits: list[CommitInfo], analyses: list[CodeAnalysis]
) -> list[str]:
    """Generate Mermaid diagrams."""
    diagrams = []

    # Commit timeline diagram
    if commits:
        timeline = "```mermaid\ngantt\n    title Recent Commits Timeline\n    dateFormat YYYY-MM-DD\n"
        for commit in commits[:5]:  # Limit to 5 for readability
            date_str = commit.date.strftime("%Y-%m-%d")
            timeline += f'    {commit.sha[:7]} :{date_str}, 1d\n'
        timeline += "```"
        diagrams.append(timeline)

    # Files changed diagram
    if commits:
        all_files = set()
        for commit in commits:
            all_files.update(commit.files_changed[:5])  # Limit per commit

        if all_files:
            files_diagram = "```mermaid\ngraph TD\n    A[Recent Changes] --> B[Files Modified]\n"
            for i, file in enumerate(list(all_files)[:10], 1):  # Limit to 10 files
                files_diagram += f'    B --> F{i}["{file}"]\n'
            files_diagram += "```"
            diagrams.append(files_diagram)

    # Importance flow diagram
    if analyses:
        importance_diagram = "```mermaid\npie title Changes by Importance\n"
        importance_counts = {}
        for analysis in analyses:
            importance_counts[analysis.importance] = (
                importance_counts.get(analysis.importance, 0) + 1
            )
        for imp, count in importance_counts.items():
            importance_diagram += f'    "{imp}" : {count}\n'
        importance_diagram += "```"
        diagrams.append(importance_diagram)

    return diagrams


def _generate_narrative(
    commits: list[CommitInfo], analyses: list[CodeAnalysis]
) -> str:
    """Generate narrative storytelling from commits."""
    if not commits:
        return "No recent commits found."

    narrative = f"In the past {len(commits)} commit(s), this repository has seen significant activity. "

    # Group by importance
    high_importance = [a for a in analyses if a.importance == "high"]
    if high_importance:
        narrative += f"Notably, {len(high_importance)} high-priority change(s) were made, "
        narrative += "indicating critical updates to the codebase. "

    # Summarize themes
    themes = []
    for commit, analysis in zip(commits, analyses):
        msg_lower = commit.message.lower()
        if "test" in msg_lower:
            themes.append("testing")
        elif "fix" in msg_lower or "bug" in msg_lower:
            themes.append("bug fixes")
        elif "feat" in msg_lower or "feature" in msg_lower:
            themes.append("new features")

    if themes:
        unique_themes = list(dict.fromkeys(themes))
        narrative += f"The changes primarily focus on: {', '.join(unique_themes)}. "

    narrative += "These updates demonstrate active development and continuous improvement of the project. "
    narrative += "The suggested next steps provide a clear roadmap for maintaining code quality and expanding functionality."

    return narrative


async def save_documentation(
    result: DocumentationResult, output_path: Path, repo_name: str
) -> None:
    """
    Save generated documentation to files.

    Args:
        result: DocumentationResult to save
        output_path: Directory to save documentation
        repo_name: Name of the repository
    """
    output_path.mkdir(parents=True, exist_ok=True)

    # Save main markdown
    main_doc = output_path / "CHANGES.md"
    main_doc.write_text(result.markdown_content)

    # Save narrative
    narrative_doc = output_path / "NARRATIVE.md"
    narrative_doc.write_text(f"# {repo_name} - Development Narrative\n\n{result.narrative}\n")

    # Save Mermaid diagrams
    if result.mermaid_diagrams:
        diagrams_doc = output_path / "DIAGRAMS.md"
        diagrams_content = "# Diagrams\n\n" + "\n\n".join(result.mermaid_diagrams)
        diagrams_doc.write_text(diagrams_content)

    # Save next steps
    if result.next_steps:
        next_steps_doc = output_path / "NEXT_STEPS.md"
        next_steps_content = "# Suggested Next Steps\n\n"
        for i, step in enumerate(result.next_steps, 1):
            next_steps_content += f"{i}. {step}\n"
        next_steps_doc.write_text(next_steps_content)
