"""Component: Generate documentation from analysis results."""

from pathlib import Path
from typing import Optional

from docweave.components.copilot_integration import (
    generate_diagrams_with_copilot,
    generate_integration_insights_with_copilot,
    generate_narrative_with_copilot,
)
from docweave.types.models import CodeAnalysis, CommitInfo, DocumentationResult


def _format_commits_for_copilot(commits: list[CommitInfo]) -> str:
    """Format commits as text for Copilot prompts."""
    lines = []
    for c in commits:
        lines.append(f"- {c.sha} | {c.date.strftime('%Y-%m-%d')} | {c.author}")
        lines.append(f"  {c.message.split(chr(10))[0][:100]}")
        lines.append(f"  Files: {', '.join(c.files_changed[:8])}")
    return "\n".join(lines)


def _format_analyses_for_copilot(analyses: list[CodeAnalysis]) -> str:
    """Format analyses as text for Copilot prompts."""
    lines = []
    for i, a in enumerate(analyses, 1):
        lines.append(f"Commit {i}: {a.summary}")
        lines.append(f"  Why: {a.why}")
        lines.append(f"  Importance: {a.importance}")
        lines.append(f"  Next: {', '.join(a.next_steps[:3])}")
    return "\n".join(lines)


async def generate_documentation(
    commits: list[CommitInfo],
    analyses: list[CodeAnalysis],
    repo_name: str,
    copilot_available: bool = False,
) -> DocumentationResult:
    """
    Generate markdown documentation and Mermaid diagrams from commits and analyses.

    When copilot_available is True, uses GitHub Copilot CLI for deeper diagrams,
    narrative, and integration insights.

    Args:
        commits: List of commit information
        analyses: List of code analyses from Copilot
        repo_name: Name of the repository
        copilot_available: Whether to use Copilot for enhanced diagrams/narrative

    Returns:
        DocumentationResult with generated content
    """
    markdown = _generate_markdown(commits, analyses, repo_name)

    commits_text = _format_commits_for_copilot(commits)
    analyses_text = _format_analyses_for_copilot(analyses)

    # Diagrams: Copilot deep-dive when available, else heuristic baseline
    heuristic_diagrams = _generate_mermaid_diagrams(commits, analyses)
    if copilot_available:
        copilot_diagrams = await generate_diagrams_with_copilot(
            commits_text, analyses_text, repo_name
        )
        mermaid_diagrams = (
            copilot_diagrams + heuristic_diagrams
            if copilot_diagrams
            else heuristic_diagrams
        )
    else:
        mermaid_diagrams = heuristic_diagrams

    # Narrative: Copilot deep-dive or heuristic
    if copilot_available:
        narrative = await generate_narrative_with_copilot(
            commits_text, analyses_text, repo_name
        )
    else:
        narrative = ""
    if not narrative:
        narrative = _generate_narrative(commits, analyses)

    # Integration insights (Copilot only)
    integration_insights = ""
    if copilot_available:
        integration_insights = await generate_integration_insights_with_copilot(
            commits_text, analyses_text, repo_name
        )

    next_steps = []
    for analysis in analyses:
        next_steps.extend(analysis.next_steps)
    next_steps = list(dict.fromkeys(next_steps))[:5]

    return DocumentationResult(
        markdown_content=markdown,
        mermaid_diagrams=mermaid_diagrams,
        narrative=narrative,
        next_steps=next_steps,
        integration_insights=integration_insights,
    )


def _generate_markdown(
    commits: list[CommitInfo], analyses: list[CodeAnalysis], repo_name: str
) -> str:
    """Generate markdown documentation."""
    md = f"# {repo_name} - Recent Changes Documentation\n\n"
    md += f"*Generated by DocWeave - Documentation companion powered by GitHub Copilot CLI*\n\n"
    md += "---\n\n"

    for i, (commit, analysis) in enumerate(zip(commits, analyses), 1):
        md += f"## Commit {i}: {commit.message.split(chr(10))[0]}\n\n"
        md += f"**SHA:** `{commit.sha}`  \n"
        md += f"**Author:** {commit.author}  \n"
        md += f"**Date:** {commit.date.strftime('%Y-%m-%d %H:%M:%S')}  \n"
        md += f"**Changes:** +{commit.additions} / -{commit.deletions} lines  \n\n"

        md += f"### Summary\n\n{analysis.summary}\n\n"

        md += f"### Why This Change?\n\n{analysis.why}\n\n"

        md += f"### Importance: {analysis.importance.upper()}\n\n"

        if commit.files_changed:
            md += f"### Files Changed\n\n"
            for file in commit.files_changed[:10]:  # Limit to 10 files
                md += f"- `{file}`\n"
            if len(commit.files_changed) > 10:
                md += f"- *... and {len(commit.files_changed) - 10} more files*\n"
            md += "\n"

        if analysis.next_steps:
            md += f"### Suggested Next Steps\n\n"
            for step in analysis.next_steps:
                md += f"- {step}\n"
            md += "\n"

        md += "---\n\n"

    return md


def _generate_mermaid_diagrams(
    commits: list[CommitInfo], analyses: list[CodeAnalysis]
) -> list[str]:
    """Generate Mermaid diagrams."""
    diagrams = []

    # Commit timeline diagram
    if commits:
        timeline = "```mermaid\ngantt\n    title Recent Commits Timeline\n    dateFormat YYYY-MM-DD\n"
        for commit in commits[:5]:  # Limit to 5 for readability
            date_str = commit.date.strftime("%Y-%m-%d")
            timeline += f'    {commit.sha[:7]} :{date_str}, 1d\n'
        timeline += "```"
        diagrams.append(timeline)

    # Files changed diagram
    if commits:
        all_files = set()
        for commit in commits:
            all_files.update(commit.files_changed[:5])  # Limit per commit

        if all_files:
            files_diagram = "```mermaid\ngraph TD\n    A[Recent Changes] --> B[Files Modified]\n"
            for i, file in enumerate(list(all_files)[:10], 1):  # Limit to 10 files
                files_diagram += f'    B --> F{i}["{file}"]\n'
            files_diagram += "```"
            diagrams.append(files_diagram)

    # Importance flow diagram
    if analyses:
        importance_diagram = "```mermaid\npie title Changes by Importance\n"
        importance_counts = {}
        for analysis in analyses:
            importance_counts[analysis.importance] = (
                importance_counts.get(analysis.importance, 0) + 1
            )
        for imp, count in importance_counts.items():
            importance_diagram += f'    "{imp}" : {count}\n'
        importance_diagram += "```"
        diagrams.append(importance_diagram)

    return diagrams


def _generate_narrative(
    commits: list[CommitInfo], analyses: list[CodeAnalysis]
) -> str:
    """Generate narrative storytelling from commits."""
    if not commits:
        return "No recent commits found."

    narrative = f"In the past {len(commits)} commit(s), this repository has seen significant activity. "

    # Group by importance
    high_importance = [a for a in analyses if a.importance == "high"]
    if high_importance:
        narrative += f"Notably, {len(high_importance)} high-priority change(s) were made, "
        narrative += "indicating critical updates to the codebase. "

    # Summarize themes
    themes = []
    for commit, analysis in zip(commits, analyses):
        msg_lower = commit.message.lower()
        if "test" in msg_lower:
            themes.append("testing")
        elif "fix" in msg_lower or "bug" in msg_lower:
            themes.append("bug fixes")
        elif "feat" in msg_lower or "feature" in msg_lower:
            themes.append("new features")

    if themes:
        unique_themes = list(dict.fromkeys(themes))
        narrative += f"The changes primarily focus on: {', '.join(unique_themes)}. "

    narrative += "These updates demonstrate active development and continuous improvement of the project. "
    narrative += "The suggested next steps provide a clear roadmap for maintaining code quality and expanding functionality."

    return narrative


async def save_documentation(
    result: DocumentationResult, output_path: Path, repo_name: str
) -> None:
    """
    Save generated documentation to files.

    Args:
        result: DocumentationResult to save
        output_path: Directory to save documentation (should be DocweaveDocs)
        repo_name: Name of the repository
    """
    output_path.mkdir(parents=True, exist_ok=True)

    # Save main markdown
    main_doc = output_path / "CHANGES.md"
    main_doc.write_text(result.markdown_content)

    # Save narrative
    narrative_doc = output_path / "NARRATIVE.md"
    narrative_doc.write_text(f"# {repo_name} - Development Narrative\n\n{result.narrative}\n")

    # Save Mermaid diagrams
    if result.mermaid_diagrams:
        diagrams_doc = output_path / "DIAGRAMS.md"
        diagrams_content = "# Diagrams\n\n" + "\n\n".join(result.mermaid_diagrams)
        diagrams_doc.write_text(diagrams_content)

    # Save next steps
    if result.next_steps:
        next_steps_doc = output_path / "NEXT_STEPS.md"
        next_steps_content = "# Suggested Next Steps\n\n"
        for i, step in enumerate(result.next_steps, 1):
            next_steps_content += f"{i}. {step}\n"
        next_steps_doc.write_text(next_steps_content)

    # Save integration insights (Copilot-generated)
    if result.integration_insights:
        integration_doc = output_path / "INTEGRATION.md"
        integration_doc.write_text(
            f"# {repo_name} - Integration & Architecture Insights\n\n"
            f"*Generated by DocWeave with GitHub Copilot CLI*\n\n"
            f"{result.integration_insights}\n"
        )
