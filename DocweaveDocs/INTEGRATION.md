# DocWeave - Integration & Architecture Insights

*Generated by DocWeave with GitHub Copilot CLI*

## Where Integrations Are Generated or Configured

DocWeave integrates with GitHub Copilot CLI through the `components/copilot_integration.py` module. External integrations are configured via subprocess invocation using the `copilot -p` command-line interface with structured prompts. The integration discovery happens at startup in `lib/copilot_check.py`, which detects Copilot CLI availability via version check before any analysis begins. All external service calls (Copilot) are routed through `_invoke_copilot()` with configurable timeouts and prompt size limits (25KB max), ensuring controlled resource consumption and graceful degradation when services are unavailable.

## Best Way to Solve Login and Authentication

DocWeave handles authentication through environment variables read by the Copilot CLI subprocess. Users set `GH_TOKEN` or `GITHUB_TOKEN` before running the tool, avoiding credential storage within the application. The `check_copilot_cli_installed()` function performs a pre-flight check without requiring credentials, delegating all authentication responsibility to Copilot CLI itself. If authentication fails, the system automatically falls back to heuristic-based analysis using regex patterns on commit messages and diffs, so the tool never breaks due to auth issues. For production integration with other services, follow this same pattern: configure credentials via environment variables, check availability upfront, and provide robust fallback logic.

## Key Integration Points and How to Extend Them

The primary extension point is `components/copilot_integration.py`, which contains four async functions that can be customized: `analyze_with_copilot()` for commit analysis with fallback to `_create_enhanced_analysis()`, `generate_diagrams_with_copilot()` for Mermaid generation, `generate_narrative_with_copilot()` for story-based documentation, and `generate_integration_insights_with_copilot()` for architectural guidance. To add a new external service, create a new function following the pattern: invoke the service via subprocess or HTTP, parse structured JSON responses, and provide a heuristic fallback. The CLI in `cli.py` orchestrates these components sequentially through `analyze_recent_commits()` then `generate_documentation()`, both of which can be extended to call additional integration points. Register new integrations in `types/models.py` by extending the `DocumentationResult` dataclass to hold additional insights.

## Gotchas and Conventions for Adding New Integrations

Always implement graceful fallback logic; DocWeave's philosophy is that missing integrations should never block functionality. Use async/await consistently since the CLI runs `asyncio.run()` for the entire analysis pipeline. Respect subprocess timeout limits (COPILOT_TIMEOUT = 60 seconds) and response size limits (MAX_DIFF_CHARS = 6000) to prevent hanging or overwhelming LLM context windows. Strip usage statistics from Copilot responses using regex patterns like `_strip_usage_stats()` to avoid parsing artifacts. When creating prompts for external AI services, request JSON-only responses with minimal formatting to ensure reliable parsing. Store all external service configuration (API keys, endpoints) as environment variables, never in code. Test fallback paths thoroughly; approximately 40% of users will hit Copilot CLI unavailability based on the tool's graceful-degradation architecture.
