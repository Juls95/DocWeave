# DocWeave - Integration & Architecture Insights

*Generated by DocWeave with GitHub Copilot CLI*

## Integration Configuration and Generation

Integrations in DocWeave are generated or configured at two points: the API layer via FastAPI endpoints in `src/docweave/app.py` and the CLI layer via Click commands in `src/docweave/cli.py`. External service integrations like Copilot are instantiated on-demand through subprocess invocation in `components/copilot_integration.py` rather than through a centralized configuration management system. The pattern is minimal and direct: services are invoked when requests arrive, with status checks performed via `/api/health` and `/api/copilot/check` endpoints. For Git-based integrations, the codebase uses GitPython's `Repo` class directly without an abstraction layer. New integrations follow the same pattern of direct service invocation, with data transformation handled through typed dataclasses in `types/models.py`.

## Authentication and Login Strategy

DocWeave currently has no built-in authentication system. Instead, authentication is handled externally: Copilot CLI requires pre-authentication through `copilot` interactive command and `/login`, while Git operations assume the local repository already has working credentials via SSH keys or Git config. This out-of-band authentication approach works for the current CLI-first architecture where the tool operates within a developer's existing authenticated environment. To extend this for multi-user or API scenarios, implement OAuth2 or token-based auth at the FastAPI layer, then pass authenticated context to service invocation functions. The cleanest approach is to add a configuration object passed through the async call chain, preserving the current minimal footprint while enabling credential management.

## Key Integration Points and Extension Patterns

The primary extension point is the AI analysis layer in `components/copilot_integration.py`, where new analyses are added as async functions following the pattern of invoking Copilot via `_invoke_copilot(prompt)` with JSON parsing and a heuristic fallback. Data sources live in `features/commit_analysis.py` where structured analysis functions return typed dataclasses; this layer can be extended to support additional VCS systems or code data sources. API endpoints in `app.py` use Pydantic models for validation and can be extended with new routes for webhooks or external service callbacks. The CLI layer in `cli.py` uses Click decorators and is structured for adding new commands alongside the existing `analyze` command. All new integrations should return data as typed dataclasses to maintain consistency with the rest of the codebase and ensure type safety across the stack.

## Conventions and Gotchas for New Integrations

There is no configuration management system in place; all service parameters are hardcoded constants like `MAX_DIFF_CHARS = 6000` and `COPILOT_TIMEOUT = 60`. Before adding integrations that require API keys or credentials, implement environment variable loading using `python-dotenv`. The Copilot CLI integration works through subprocess invocation with a 60-second timeout and truncates prompts to 25KB; any new AI service integration should account for similar constraints and implement equivalent fallback heuristics. There is no service registry or dependency injection container, so new integrations are invoked directly via imports. Importantly, all integrations currently assume the caller has pre-existing access and authentication to underlying services; implementing service-to-service authentication will require threading credential context through the async call chain. No retry logic or rate limiting exists, which is essential to add when integrating cloud APIs to avoid cascading failures.
