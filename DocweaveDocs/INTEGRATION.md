# DocWeave - Integration & Architecture Insights

*Generated by DocWeave with GitHub Copilot CLI*

## Where Integrations Are Generated or Configured

Integrations in DocWeave exist at two architectural layers. The API layer operates through FastAPI endpoints in `src/docweave/app.py` with health check endpoints at `/api/health` and `/api/copilot/check`. The CLI layer flows through Click commands in `src/docweave/cli.py`. External services like Copilot are invoked on-demand through subprocess calls in `components/copilot_integration.py` rather than through a centralized registry. Git operations leverage GitPython's `Repo` class directly. New integrations follow the direct invocation pattern with data transformation handled through typed dataclasses in `types/models.py`.

## Authentication Strategy for Current Architecture

DocWeave currently implements no native authentication system. Instead it relies on external, pre-authenticated environments: Copilot CLI requires prior authentication through the `copilot` command and `/login`, while Git operations assume SSH keys or Git config credentials already exist locally. This out-of-band approach suits the CLI-first architecture where the tool operates within a developer's authenticated environment. To extend for multi-user or API scenarios, add OAuth2 or token-based authentication at the FastAPI layer, then pass authenticated context through the async call chain. The minimal implementation adds a configuration object to service invocation functions, preserving the current lightweight design while enabling credential management.

## Key Integration Points and Extension Patterns

The primary extension point is the AI analysis layer in `components/copilot_integration.py`, where new analyses are async functions invoking Copilot via `_invoke_copilot(prompt)` with JSON parsing and heuristic fallbacks. Data sources live in `features/commit_analysis.py` as structured analysis functions returning typed dataclasses; this layer extends to support additional version control systems or code sources. API endpoints in `app.py` use Pydantic models for validation and can be extended with webhook routes or external service callbacks. The CLI uses Click decorators for easy command extension alongside the existing `analyze` command. All new integrations must return typed dataclasses for consistency and type safety across the stack.

## Conventions and Gotchas for New Integrations

No configuration management system exists; service parameters are hardcoded constants like `MAX_DIFF_CHARS = 6000` and `COPILOT_TIMEOUT = 60`. Before adding integrations requiring API keys, implement environment variable loading with `python-dotenv`. Copilot integration uses subprocess invocation with a 60-second timeout and truncates prompts to 25KB; plan equivalent constraints for new AI services with fallback heuristics. No service registry or dependency injection container exists, so integrations invoke directly via imports. All current integrations assume pre-existing caller access and authentication to underlying services; service-to-service authentication requires threading credential context through async chains. Critically, no retry logic or rate limiting exists, which must be added for cloud APIs to prevent cascading failures.
